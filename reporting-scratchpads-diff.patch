diff --git a/config.def.h b/config.def.h
index db0babc..780aa96 100644
--- a/config.def.h
+++ b/config.def.h
@@ -135,6 +135,8 @@ static const Key keys[] = {
 	{ MODKEY,                    XKB_KEY_space,      setlayout,      {0} },
 	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_space,      togglefloating, {0} },
 	{ MODKEY,                    XKB_KEY_e,         togglefullscreen, {0} },
+	{ MODKEY,                    XKB_KEY_d,          togglescratchpad, {0} },
+	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_D,          toggleinscratchpad, {0} },
 	{ MODKEY,                    XKB_KEY_0,          view,           {.ui = ~0} },
 	{ MODKEY|WLR_MODIFIER_SHIFT, XKB_KEY_parenright, tag,            {.ui = ~0} },
 	{ MODKEY,                    XKB_KEY_comma,      focusmon,       {.i = WLR_DIRECTION_LEFT} },
diff --git a/dwl.c b/dwl.c
index ef27a1d..97614f8 100644
--- a/dwl.c
+++ b/dwl.c
@@ -130,6 +130,7 @@ typedef struct {
 	uint32_t tags;
 	int isfloating, isurgent, isfullscreen;
 	uint32_t resize; /* configure serial of a pending resize */
+	int inscratchpad;
 } Client;
 
 typedef struct {
@@ -315,6 +316,8 @@ static void togglefloating(const Arg *arg);
 static void togglefullscreen(const Arg *arg);
 static void toggletag(const Arg *arg);
 static void toggleview(const Arg *arg);
+static void togglescratchpad(const Arg *arg);
+static void toggleinscratchpad(const Arg *arg);
 static void unlocksession(struct wl_listener *listener, void *data);
 static void unmaplayersurfacenotify(struct wl_listener *listener, void *data);
 static void unmapnotify(struct wl_listener *listener, void *data);
@@ -424,6 +427,7 @@ applyrules(Client *c)
 	Monitor *mon = selmon, *m;
 
 	c->isfloating = client_is_float_type(c);
+	c->inscratchpad = 0;
 	if (!(appid = client_get_appid(c)))
 		appid = broken;
 	if (!(title = client_get_title(c)))
@@ -1821,10 +1825,15 @@ printstatus(void)
 	Client *c;
 	uint32_t occ, urg, sel;
 	const char *appid, *title;
+	int scratchpads_count;
 
 	wl_list_for_each(m, &mons, link) {
 		occ = urg = 0;
+		scratchpads_count = 0;
 		wl_list_for_each(c, &clients, link) {
+			if (c->inscratchpad != 0) {
+				scratchpads_count++;
+			}
 			if (c->mon != m)
 				continue;
 			occ |= c->tags;
@@ -1851,6 +1860,7 @@ printstatus(void)
 		printf("%s tags %u %u %u %u\n", m->wlr_output->name, occ, m->tagset[m->seltags],
 				sel, urg);
 		printf("%s layout %s\n", m->wlr_output->name, m->ltsymbol);
+		printf("%s scratchpads_count %d\n", m->wlr_output->name, scratchpads_count);
 	}
 	fflush(stdout);
 }
@@ -2485,6 +2495,50 @@ toggleview(const Arg *arg)
 	printstatus();
 }
 
+void
+togglescratchpad(const Arg *arg)
+{
+	Client *c;
+	int iscratchpadvisible = 1;
+	int found = 0;
+
+	wl_list_for_each(c, &clients, link) {
+		if (c->inscratchpad) {
+			found = 1;
+			if (!VISIBLEON(c, selmon)) {
+				iscratchpadvisible = 0;
+			}
+		}
+	}
+	if (!found)
+		return;
+	wl_list_for_each(c, &clients, link) {
+		if (c->inscratchpad) {
+			c->tags = iscratchpadvisible ? 0 : selmon->tagset[selmon->seltags];
+			focusclient(c, 1);
+		}
+	}
+	arrange(selmon);
+}
+
+void
+toggleinscratchpad(const Arg *arg)
+{
+	Client *sel = focustop(selmon);
+	if (!sel)
+		return;
+	if (!sel->mon)
+		return;
+	sel->inscratchpad = !sel->inscratchpad;
+	if (sel->inscratchpad) {
+		sel->tags = 0;
+	} else {
+		sel->tags = selmon->tagset[selmon->seltags];
+	}
+	arrange(selmon);
+	printstatus();
+}
+
 void
 unlocksession(struct wl_listener *listener, void *data)
 {
