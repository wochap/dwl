From cd8040c4e4f22514837a2c768a8a41f0e9820900 Mon Sep 17 00:00:00 2001
From: wochap <gean.marroquin@gmail.com>
Date: Fri, 5 Apr 2024 09:46:32 -0500
Subject: [PATCH 1/3] implement wlrfx/scenefx shadows

add options for shadow and corner_radius
---
 Makefile     |   2 +-
 client.h     |  11 ++++-
 config.def.h |   8 ++++
 dwl.c        | 122 ++++++++++++++++++++++++++++++++++++++++++++++++---
 4 files changed, 134 insertions(+), 9 deletions(-)

diff --git a/Makefile b/Makefile
index 6cde460..f235edf 100644
--- a/Makefile
+++ b/Makefile
@@ -9,7 +9,7 @@ DWLDEVCFLAGS = -g -pedantic -Wall -Wextra -Wdeclaration-after-statement -Wno-unu
 	-Werror=strict-prototypes -Werror=implicit -Werror=return-type -Werror=incompatible-pointer-types
 
 # CFLAGS / LDFLAGS
-PKGS      = wlroots wayland-server xkbcommon libinput $(XLIBS)
+PKGS      = scenefx wlroots wayland-server xkbcommon libinput $(XLIBS)
 DWLCFLAGS = `$(PKG_CONFIG) --cflags $(PKGS)` $(DWLCPPFLAGS) $(DWLDEVCFLAGS) $(CFLAGS)
 LDLIBS    = `$(PKG_CONFIG) --libs $(PKGS)` $(LIBS)
 
diff --git a/client.h b/client.h
index 71c7d76..6532e05 100644
--- a/client.h
+++ b/client.h
@@ -131,7 +131,7 @@ client_get_appid(Client *c)
 	return c->surface.xdg->toplevel->app_id;
 }
 
-static inline void
+static inline int
 client_get_clip(Client *c, struct wlr_box *clip)
 {
 	struct wlr_box xdg_geom = {0};
@@ -144,12 +144,19 @@ client_get_clip(Client *c, struct wlr_box *clip)
 
 #ifdef XWAYLAND
 	if (client_is_x11(c))
-		return;
+		return 1;
 #endif
 
 	wlr_xdg_surface_get_geometry(c->surface.xdg, &xdg_geom);
 	clip->x = xdg_geom.x;
 	clip->y = xdg_geom.y;
+
+	if (xdg_geom.width <= c->geom.width - c->bw 
+			&& xdg_geom.height <= c->geom.height - c->bw) {
+		return 0;
+	}
+
+	return 1;
 }
 
 static inline void
diff --git a/config.def.h b/config.def.h
index db0babc..521bd04 100644
--- a/config.def.h
+++ b/config.def.h
@@ -12,6 +12,14 @@ static const float focuscolor[]            = COLOR(0x005577ff);
 static const float urgentcolor[]           = COLOR(0xff0000ff);
 /* To conform the xdg-protocol, set the alpha to zero to restore the old behavior */
 static const float fullscreen_bg[]         = {0.1, 0.1, 0.1, 1.0}; /* You can also use glsl colors */
+static const int shadow = 1;
+static const int shadow_only_floating = 0; /* only apply shadow to floating windows */
+static const struct wlr_render_color shadow_color = COLOR(0x0000FFff);
+static const struct wlr_render_color shadow_color_focus = COLOR(0xFF0000ff);
+static const int shadow_blur_sigma = 20;
+static const int shadow_blur_sigma_focus = 40;
+static const char *const shadow_ignore_list[] = { "xdg-desktop-portal-gtk", "cpupower-gui", NULL }; /* list of app-id to ignore */
+static const int corner_radius = 0;
 
 /* tagging - TAGCOUNT must be no greater than 31 */
 #define TAGCOUNT (9)
diff --git a/dwl.c b/dwl.c
index ef27a1d..e0e8222 100644
--- a/dwl.c
+++ b/dwl.c
@@ -9,6 +9,9 @@
 #include <stdlib.h>
 #include <sys/wait.h>
 #include <time.h>
+#include <scenefx/fx_renderer/fx_renderer.h>
+#include <scenefx/types/fx/shadow_data.h>
+#include <scenefx/types/wlr_scene.h>
 #include <unistd.h>
 #include <wayland-server-core.h>
 #include <wlr/backend.h>
@@ -37,7 +40,6 @@
 #include <wlr/types/wlr_presentation_time.h>
 #include <wlr/types/wlr_primary_selection.h>
 #include <wlr/types/wlr_primary_selection_v1.h>
-#include <wlr/types/wlr_scene.h>
 #include <wlr/types/wlr_screencopy_v1.h>
 #include <wlr/types/wlr_seat.h>
 #include <wlr/types/wlr_server_decoration.h>
@@ -130,6 +132,10 @@ typedef struct {
 	uint32_t tags;
 	int isfloating, isurgent, isfullscreen;
 	uint32_t resize; /* configure serial of a pending resize */
+
+	float opacity;
+	int corner_radius;
+	struct shadow_data shadow_data;
 } Client;
 
 typedef struct {
@@ -327,6 +333,8 @@ static Monitor *xytomon(double x, double y);
 static void xytonode(double x, double y, struct wlr_surface **psurface,
 		Client **pc, LayerSurface **pl, double *nx, double *ny);
 static void zoom(const Arg *arg);
+static int in_shadow_ignore_list(const char *str);
+static void output_configure_scene(struct wlr_scene_node *node, Client *c);
 
 /* variables */
 static const char broken[] = "broken";
@@ -440,6 +448,13 @@ applyrules(Client *c)
 					mon = m;
 		}
 	}
+	if (shadow_only_floating) {
+		if (c->isfloating && !in_shadow_ignore_list(appid)) {
+			c->shadow_data.enabled = 1;
+		} else {
+			c->shadow_data.enabled = 0;
+		}
+	}
 	wlr_scene_node_reparent(&c->scene->node, layers[c->isfloating ? LyrFloat : LyrTile]);
 	setmon(c, mon, newtags);
 }
@@ -975,6 +990,13 @@ createnotify(struct wl_listener *listener, void *data)
 	wlr_xdg_toplevel_set_wm_capabilities(xdg_surface->toplevel,
 			WLR_XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN);
 
+	c->opacity = 1;
+	c->corner_radius = corner_radius;
+	c->shadow_data = shadow_data_get_default();
+	c->shadow_data.enabled = shadow_only_floating != 1 && !in_shadow_ignore_list(client_get_appid(c));
+	c->shadow_data.blur_sigma = shadow_blur_sigma;
+	c->shadow_data.color = shadow_color;
+
 	LISTEN(&xdg_surface->surface->events.commit, &c->commit, commitnotify);
 	LISTEN(&xdg_surface->surface->events.map, &c->map, mapnotify);
 	LISTEN(&xdg_surface->surface->events.unmap, &c->unmap, unmapnotify);
@@ -1204,8 +1226,11 @@ focusclient(Client *c, int lift)
 
 		/* Don't change border color if there is an exclusive focus or we are
 		 * handling a drag operation */
-		if (!exclusive_focus && !seat->drag)
+		if (!exclusive_focus && !seat->drag) {
 			client_set_border_color(c, focuscolor);
+			c->shadow_data.blur_sigma = shadow_blur_sigma_focus;
+			c->shadow_data.color = shadow_color_focus;
+		}
 	}
 
 	/* Deactivate old client if focus is changing */
@@ -1223,6 +1248,8 @@ focusclient(Client *c, int lift)
 		 * and probably other clients */
 		} else if (old_c && !client_is_unmanaged(old_c) && (!c || !client_wants_focus(c))) {
 			client_set_border_color(old_c, bordercolor);
+			old_c->shadow_data.blur_sigma = shadow_blur_sigma;
+			old_c->shadow_data.color = shadow_color;
 
 			client_activate_surface(old, 0);
 		}
@@ -1554,6 +1581,13 @@ mapnotify(struct wl_listener *listener, void *data)
 	 /* TODO: https://github.com/djpohly/dwl/pull/334#issuecomment-1330166324 */
 	if (c->type == XDGShell && (p = client_get_parent(c))) {
 		c->isfloating = 1;
+		if (shadow_only_floating) {
+			if (!in_shadow_ignore_list(client_get_appid(c))) {
+				c->shadow_data.enabled = 1;
+			} else {
+				c->shadow_data.enabled = 0;
+			}
+		}
 		wlr_scene_node_reparent(&c->scene->node, layers[LyrFloat]);
 		setmon(c, p->mon, p->tags);
 	} else {
@@ -1878,6 +1912,10 @@ rendermon(struct wl_listener *listener, void *data)
 		if (c->resize && !c->isfloating && client_is_rendered_on_mon(c, m) && !client_is_stopped(c))
 			goto skip;
 
+	if (shadow) {
+		output_configure_scene(&m->scene_output->scene->tree.node, NULL);
+	}
+
 	/*
 	 * HACK: The "correct" way to set the gamma is to commit it together with
 	 * the rest of the state in one go, but to do that we would need to rewrite
@@ -1936,6 +1974,7 @@ resize(Client *c, struct wlr_box geo, int interact)
 {
 	struct wlr_box *bbox = interact ? &sgeom : &c->mon->w;
 	struct wlr_box clip;
+	int should_clip;
 	client_set_bounds(c, geo.width, geo.height);
 	c->geom = geo;
 	applybounds(c, bbox);
@@ -1954,8 +1993,12 @@ resize(Client *c, struct wlr_box geo, int interact)
 	/* this is a no-op if size hasn't changed */
 	c->resize = client_set_size(c, c->geom.width - 2 * c->bw,
 			c->geom.height - 2 * c->bw);
-	client_get_clip(c, &clip);
-	wlr_scene_subsurface_tree_set_clip(&c->scene_surface->node, &clip);
+	should_clip = client_get_clip(c, &clip);
+	if (should_clip) {
+		wlr_scene_subsurface_tree_set_clip(&c->scene_surface->node, &clip);
+	} else {
+		wlr_scene_subsurface_tree_set_clip(&c->scene_surface->node, NULL);
+	}
 }
 
 void
@@ -2048,6 +2091,13 @@ void
 setfloating(Client *c, int floating)
 {
 	c->isfloating = floating;
+	if (shadow_only_floating) {
+		if (c->isfloating && !in_shadow_ignore_list(client_get_appid(c))) {
+			c->shadow_data.enabled = 1;
+		} else {
+			c->shadow_data.enabled = 0;
+		}
+	}
 	if (!c->mon)
 		return;
 	wlr_scene_node_reparent(&c->scene->node, layers[c->isfullscreen
@@ -2196,7 +2246,7 @@ setup(void)
 	 * can also specify a renderer using the WLR_RENDERER env var.
 	 * The renderer is responsible for defining the various pixel formats it
 	 * supports for shared memory, this configures that for clients. */
-	if (!(drw = wlr_renderer_autocreate(backend)))
+	if (!(drw = fx_renderer_create(backend)))
 		die("couldn't create renderer");
 
 	/* Create shm, drm and linux_dmabuf interfaces by ourselves.
@@ -2650,8 +2700,11 @@ urgent(struct wl_listener *listener, void *data)
 	if (!c || c == focustop(selmon))
 		return;
 
-	if (client_surface(c)->mapped)
+	if (client_surface(c)->mapped) {
 		client_set_border_color(c, urgentcolor);
+		c->shadow_data.blur_sigma = shadow_blur_sigma_focus;
+		c->shadow_data.color = shadow_color_focus;
+	}
 	c->isurgent = 1;
 	printstatus();
 }
@@ -2746,6 +2799,63 @@ zoom(const Arg *arg)
 	arrange(selmon);
 }
 
+int
+in_shadow_ignore_list(const char *str) {
+	for (int i = 0; shadow_ignore_list[i] != NULL; i++) {
+		if (strcmp(shadow_ignore_list[i], str) == 0) {
+			return 1;
+		}
+	}
+	return 0;
+}
+
+void 
+output_configure_scene(struct wlr_scene_node *node, Client *c)
+{
+	Client *_c;
+
+	if (!node->enabled) {
+		return;
+	}
+
+	_c = node->data;
+	if (_c) {
+		c = _c;
+	}
+
+	if (node->type == WLR_SCENE_NODE_BUFFER) {
+		struct wlr_xdg_surface *xdg_surface;
+		struct wlr_scene_buffer *buffer = wlr_scene_buffer_from_node(node);
+
+		struct wlr_scene_surface * scene_surface =
+			wlr_scene_surface_try_from_buffer(buffer);
+		if (!scene_surface) {
+			return;
+		}
+
+		xdg_surface = wlr_xdg_surface_try_from_wlr_surface(scene_surface->surface);
+
+		if (c &&
+				xdg_surface &&
+				xdg_surface->role == WLR_XDG_SURFACE_ROLE_TOPLEVEL) {
+			// TODO: Be able to set whole decoration_data instead of calling
+			// each individually?
+			wlr_scene_buffer_set_opacity(buffer, c->opacity);
+
+			if (!wlr_subsurface_try_from_wlr_surface(xdg_surface->surface)) {
+				wlr_scene_buffer_set_corner_radius(buffer, c->corner_radius);
+				wlr_scene_buffer_set_shadow_data(buffer, c->shadow_data);
+			}
+		}
+	} else if (node->type == WLR_SCENE_NODE_TREE) {
+		struct wlr_scene_tree *tree = wl_container_of(node, tree, node);
+		struct wlr_scene_node *_node;
+		wl_list_for_each(_node, &tree->children, link) {
+			output_configure_scene(_node, c);
+		}
+	}
+}
+
 #ifdef XWAYLAND
 void
 activatex11(struct wl_listener *listener, void *data)
-- 
2.43.2


From bedfa3e1e5743a002080adedaf6a7919cb539f5f Mon Sep 17 00:00:00 2001
From: wochap <gean.marroquin@gmail.com>
Date: Mon, 8 Apr 2024 21:15:29 -0500
Subject: [PATCH 2/3] implement blur

requires scenefx commit de4ec10e1ff9347b5833f00f8615d760d9378c99
---
 config.def.h |  9 +++++++++
 dwl.c        | 42 +++++++++++++++++++++++++++++++++++++-----
 2 files changed, 46 insertions(+), 5 deletions(-)

diff --git a/config.def.h b/config.def.h
index 521bd04..89a62d6 100644
--- a/config.def.h
+++ b/config.def.h
@@ -20,6 +20,15 @@ static const int shadow_blur_sigma = 20;
 static const int shadow_blur_sigma_focus = 40;
 static const char *const shadow_ignore_list[] = { "xdg-desktop-portal-gtk", "cpupower-gui", NULL }; /* list of app-id to ignore */
 static const int corner_radius = 0;
+static const int optimized_blur = 0;
+static const struct blur_data blur_data = {
+	.radius = 5, /* 0 disables blur */
+	.num_passes = 3,
+	.noise = 0.02,
+	.brightness = 0.9,
+	.contrast = 0.9,
+	.saturation = 1.1,
+};
 
 /* tagging - TAGCOUNT must be no greater than 31 */
 #define TAGCOUNT (9)
diff --git a/dwl.c b/dwl.c
index e0e8222..00a043a 100644
--- a/dwl.c
+++ b/dwl.c
@@ -10,6 +10,7 @@
 #include <sys/wait.h>
 #include <time.h>
 #include <scenefx/fx_renderer/fx_renderer.h>
+#include <scenefx/types/fx/blur_data.h>
 #include <scenefx/types/fx/shadow_data.h>
 #include <scenefx/types/wlr_scene.h>
 #include <unistd.h>
@@ -335,6 +336,7 @@ static void xytonode(double x, double y, struct wlr_surface **psurface,
 static void zoom(const Arg *arg);
 static int in_shadow_ignore_list(const char *str);
 static void output_configure_scene(struct wlr_scene_node *node, Client *c);
+static void iter_xdg_scene_buffers(struct wlr_scene_buffer *buffer, int sx, int sy, void *user_data);
 
 /* variables */
 static const char broken[] = "broken";
@@ -1545,6 +1547,8 @@ mapnotify(struct wl_listener *listener, void *data)
 			: wlr_scene_subsurface_tree_create(c->scene, client_surface(c));
 	c->scene->node.data = c->scene_surface->node.data = c;
 
+	wlr_scene_node_for_each_buffer(&c->scene_surface->node, iter_xdg_scene_buffers, c);
+
 	/* Handle unmanaged clients first so we can return prior create borders */
 	if (client_is_unmanaged(c)) {
 		client_get_geometry(c, &c->geom);
@@ -2242,6 +2246,8 @@ setup(void)
 	drag_icon = wlr_scene_tree_create(&scene->tree);
 	wlr_scene_node_place_below(&drag_icon->node, &layers[LyrBlock]->node);
 
+	wlr_scene_set_blur_data(scene, blur_data);
+
 	/* Autocreates a renderer, either Pixman, GLES2 or Vulkan for us. The user
 	 * can also specify a renderer using the WLR_RENDERER env var.
 	 * The renderer is responsible for defining the various pixel formats it
@@ -2838,12 +2844,7 @@ output_configure_scene(struct wlr_scene_node *node, Client *c)
 		if (c &&
 				xdg_surface &&
 				xdg_surface->role == WLR_XDG_SURFACE_ROLE_TOPLEVEL) {
-			// TODO: Be able to set whole decoration_data instead of calling
-			// each individually?
-			wlr_scene_buffer_set_opacity(buffer, c->opacity);
-
 			if (!wlr_subsurface_try_from_wlr_surface(xdg_surface->surface)) {
-				wlr_scene_buffer_set_corner_radius(buffer, c->corner_radius);
 				wlr_scene_buffer_set_shadow_data(buffer, c->shadow_data);
 			}
 		}
@@ -2856,6 +2857,37 @@ output_configure_scene(struct wlr_scene_node *node, Client *c)
 	}
 }
 
+void 
+iter_xdg_scene_buffers(struct wlr_scene_buffer *buffer, int sx, int sy, void *user_data) 
+{
+	Client *c = user_data;
+	struct wlr_scene_surface * scene_surface = wlr_scene_surface_try_from_buffer(buffer);
+	struct wlr_xdg_surface *xdg_surface;
+
+	if (!scene_surface) {
+		return;
+	}
+
+	xdg_surface = wlr_xdg_surface_try_from_wlr_surface(scene_surface->surface);
+
+	if (c &&
+			xdg_surface &&
+			xdg_surface->role == WLR_XDG_SURFACE_ROLE_TOPLEVEL) {
+		// TODO: Be able to set whole decoration_data instead of calling
+		// each individually?
+		wlr_scene_buffer_set_opacity(buffer, c->opacity);
+
+		if (!wlr_subsurface_try_from_wlr_surface(xdg_surface->surface)) {
+			wlr_scene_buffer_set_corner_radius(buffer, c->corner_radius);
+			// wlr_scene_buffer_set_shadow_data(buffer, c->shadow_data);
+
+			wlr_scene_buffer_set_backdrop_blur(buffer, !optimized_blur);
+			wlr_scene_buffer_set_backdrop_blur_optimized(buffer, optimized_blur);
+			wlr_scene_buffer_set_backdrop_blur_ignore_transparent(buffer, true);
+		}
+	}
+}
+
 #ifdef XWAYLAND
 void
 activatex11(struct wl_listener *listener, void *data)
-- 
2.43.2


From 11b9645c40dfa36b73436608e284144fa4460b5a Mon Sep 17 00:00:00 2001
From: wochap <gean.marroquin@gmail.com>
Date: Wed, 10 Apr 2024 09:27:08 -0500
Subject: [PATCH 3/3] feat: implement opacity

perf: update scenefx data when necessary
---
 config.def.h |  21 ++++++---
 dwl.c        | 119 ++++++++++++++++++++++++++++-----------------------
 2 files changed, 81 insertions(+), 59 deletions(-)

diff --git a/config.def.h b/config.def.h
index 89a62d6..185765a 100644
--- a/config.def.h
+++ b/config.def.h
@@ -11,18 +11,27 @@ static const float bordercolor[]           = COLOR(0x444444ff);
 static const float focuscolor[]            = COLOR(0x005577ff);
 static const float urgentcolor[]           = COLOR(0xff0000ff);
 /* To conform the xdg-protocol, set the alpha to zero to restore the old behavior */
-static const float fullscreen_bg[]         = {0.1, 0.1, 0.1, 1.0}; /* You can also use glsl colors */
-static const int shadow = 1;
+static const float fullscreen_bg[]         = {0.1, 0.1, 0.1, 0.0}; /* You can also use glsl colors */
+
+static const int opacity = 0; /* flag to enable opacity */
+static const float opacity_inactive = 0.5;
+static const float opacity_active = 1.0;
+
+static const int shadow = 1; /* flag to enable shadow */
 static const int shadow_only_floating = 0; /* only apply shadow to floating windows */
 static const struct wlr_render_color shadow_color = COLOR(0x0000FFff);
 static const struct wlr_render_color shadow_color_focus = COLOR(0xFF0000ff);
 static const int shadow_blur_sigma = 20;
 static const int shadow_blur_sigma_focus = 40;
-static const char *const shadow_ignore_list[] = { "xdg-desktop-portal-gtk", "cpupower-gui", NULL }; /* list of app-id to ignore */
-static const int corner_radius = 0;
-static const int optimized_blur = 0;
+static const char *const shadow_ignore_list[] = { "xdg-desktop-portal-gtk", NULL }; /* list of app-id to ignore */
+
+static const int corner_radius = 0; /* 0 disables corner_radius */
+
+static const int blur = 0; /* flag to enable blur */
+static const int blur_optimized = 1;
+static const int blur_ignore_transparent = 1;
 static const struct blur_data blur_data = {
-	.radius = 5, /* 0 disables blur */
+	.radius = 5,
 	.num_passes = 3,
 	.noise = 0.02,
 	.brightness = 0.9,
diff --git a/dwl.c b/dwl.c
index 00a043a..4e9614e 100644
--- a/dwl.c
+++ b/dwl.c
@@ -335,8 +335,8 @@ static void xytonode(double x, double y, struct wlr_surface **psurface,
 		Client **pc, LayerSurface **pl, double *nx, double *ny);
 static void zoom(const Arg *arg);
 static int in_shadow_ignore_list(const char *str);
-static void output_configure_scene(struct wlr_scene_node *node, Client *c);
 static void iter_xdg_scene_buffers(struct wlr_scene_buffer *buffer, int sx, int sy, void *user_data);
+static void iter_xdg_scene_buffers_shadow(struct wlr_scene_buffer *buffer, int sx, int sy, void *user_data);
 
 /* variables */
 static const char broken[] = "broken";
@@ -450,12 +450,13 @@ applyrules(Client *c)
 					mon = m;
 		}
 	}
-	if (shadow_only_floating) {
+	if (shadow && shadow_only_floating) {
 		if (c->isfloating && !in_shadow_ignore_list(appid)) {
 			c->shadow_data.enabled = 1;
 		} else {
 			c->shadow_data.enabled = 0;
 		}
+		wlr_scene_node_for_each_buffer(&c->scene_surface->node, iter_xdg_scene_buffers_shadow, c);
 	}
 	wlr_scene_node_reparent(&c->scene->node, layers[c->isfloating ? LyrFloat : LyrTile]);
 	setmon(c, mon, newtags);
@@ -992,7 +993,7 @@ createnotify(struct wl_listener *listener, void *data)
 	wlr_xdg_toplevel_set_wm_capabilities(xdg_surface->toplevel,
 			WLR_XDG_TOPLEVEL_WM_CAPABILITIES_FULLSCREEN);
 
-	c->opacity = 1;
+	c->opacity = opacity;
 	c->corner_radius = corner_radius;
 	c->shadow_data = shadow_data_get_default();
 	c->shadow_data.enabled = shadow_only_floating != 1 && !in_shadow_ignore_list(client_get_appid(c));
@@ -1230,8 +1231,18 @@ focusclient(Client *c, int lift)
 		 * handling a drag operation */
 		if (!exclusive_focus && !seat->drag) {
 			client_set_border_color(c, focuscolor);
-			c->shadow_data.blur_sigma = shadow_blur_sigma_focus;
-			c->shadow_data.color = shadow_color_focus;
+			if (shadow) {
+				c->shadow_data.blur_sigma = shadow_blur_sigma_focus;
+				c->shadow_data.color = shadow_color_focus;
+			}
+			if (opacity) {
+				c->opacity = opacity_active;
+			}
+			if (opacity) {
+				wlr_scene_node_for_each_buffer(&c->scene_surface->node, iter_xdg_scene_buffers, c);
+			} else if (shadow) {
+				wlr_scene_node_for_each_buffer(&c->scene_surface->node, iter_xdg_scene_buffers_shadow, c);
+			}
 		}
 	}
 
@@ -1250,8 +1261,18 @@ focusclient(Client *c, int lift)
 		 * and probably other clients */
 		} else if (old_c && !client_is_unmanaged(old_c) && (!c || !client_wants_focus(c))) {
 			client_set_border_color(old_c, bordercolor);
-			old_c->shadow_data.blur_sigma = shadow_blur_sigma;
-			old_c->shadow_data.color = shadow_color;
+			if (shadow) {
+				old_c->shadow_data.blur_sigma = shadow_blur_sigma;
+				old_c->shadow_data.color = shadow_color;
+			}
+			if (opacity) {
+				old_c->opacity = opacity_inactive;
+			}
+			if (opacity) {
+				wlr_scene_node_for_each_buffer(&old_c->scene_surface->node, iter_xdg_scene_buffers, old_c);
+			} else if (shadow) {
+				wlr_scene_node_for_each_buffer(&old_c->scene_surface->node, iter_xdg_scene_buffers_shadow, old_c);
+			}
 
 			client_activate_surface(old, 0);
 		}
@@ -1585,12 +1606,13 @@ mapnotify(struct wl_listener *listener, void *data)
 	 /* TODO: https://github.com/djpohly/dwl/pull/334#issuecomment-1330166324 */
 	if (c->type == XDGShell && (p = client_get_parent(c))) {
 		c->isfloating = 1;
-		if (shadow_only_floating) {
+		if (shadow && shadow_only_floating) {
 			if (!in_shadow_ignore_list(client_get_appid(c))) {
 				c->shadow_data.enabled = 1;
 			} else {
 				c->shadow_data.enabled = 0;
 			}
+			wlr_scene_node_for_each_buffer(&c->scene_surface->node, iter_xdg_scene_buffers_shadow, c);
 		}
 		wlr_scene_node_reparent(&c->scene->node, layers[LyrFloat]);
 		setmon(c, p->mon, p->tags);
@@ -1916,10 +1938,6 @@ rendermon(struct wl_listener *listener, void *data)
 		if (c->resize && !c->isfloating && client_is_rendered_on_mon(c, m) && !client_is_stopped(c))
 			goto skip;
 
-	if (shadow) {
-		output_configure_scene(&m->scene_output->scene->tree.node, NULL);
-	}
-
 	/*
 	 * HACK: The "correct" way to set the gamma is to commit it together with
 	 * the rest of the state in one go, but to do that we would need to rewrite
@@ -2095,12 +2113,13 @@ void
 setfloating(Client *c, int floating)
 {
 	c->isfloating = floating;
-	if (shadow_only_floating) {
+	if (shadow && shadow_only_floating) {
 		if (c->isfloating && !in_shadow_ignore_list(client_get_appid(c))) {
 			c->shadow_data.enabled = 1;
 		} else {
 			c->shadow_data.enabled = 0;
 		}
+		wlr_scene_node_for_each_buffer(&c->scene_surface->node, iter_xdg_scene_buffers_shadow, c);
 	}
 	if (!c->mon)
 		return;
@@ -2246,7 +2265,9 @@ setup(void)
 	drag_icon = wlr_scene_tree_create(&scene->tree);
 	wlr_scene_node_place_below(&drag_icon->node, &layers[LyrBlock]->node);
 
-	wlr_scene_set_blur_data(scene, blur_data);
+	if (blur) {
+		wlr_scene_set_blur_data(scene, blur_data);
+	}
 
 	/* Autocreates a renderer, either Pixman, GLES2 or Vulkan for us. The user
 	 * can also specify a renderer using the WLR_RENDERER env var.
@@ -2708,8 +2729,11 @@ urgent(struct wl_listener *listener, void *data)
 
 	if (client_surface(c)->mapped) {
 		client_set_border_color(c, urgentcolor);
-		c->shadow_data.blur_sigma = shadow_blur_sigma_focus;
-		c->shadow_data.color = shadow_color_focus;
+		if (shadow) {
+			c->shadow_data.blur_sigma = shadow_blur_sigma_focus;
+			c->shadow_data.color = shadow_color_focus;
+			wlr_scene_node_for_each_buffer(&c->scene_surface->node, iter_xdg_scene_buffers_shadow, c);
+		}
 	}
 	c->isurgent = 1;
 	printstatus();
@@ -2816,49 +2840,47 @@ in_shadow_ignore_list(const char *str) {
 }
 
 void 
-output_configure_scene(struct wlr_scene_node *node, Client *c)
+iter_xdg_scene_buffers(struct wlr_scene_buffer *buffer, int sx, int sy, void *user_data) 
 {
-	Client *_c;
+	Client *c = user_data;
+	struct wlr_scene_surface * scene_surface = wlr_scene_surface_try_from_buffer(buffer);
+	struct wlr_xdg_surface *xdg_surface;
 
-	if (!node->enabled) {
+	if (!scene_surface) {
 		return;
 	}
 
-	_c = node->data;
-	if (_c) {
-		c = _c;
-	}
-
-	if (node->type == WLR_SCENE_NODE_BUFFER) {
-		struct wlr_xdg_surface *xdg_surface;
-		struct wlr_scene_buffer *buffer = wlr_scene_buffer_from_node(node);
+	xdg_surface = wlr_xdg_surface_try_from_wlr_surface(scene_surface->surface);
 
-		struct wlr_scene_surface * scene_surface =
-			wlr_scene_surface_try_from_buffer(buffer);
-		if (!scene_surface) {
-			return;
+	if (c &&
+			xdg_surface &&
+			xdg_surface->role == WLR_XDG_SURFACE_ROLE_TOPLEVEL) {
+		// TODO: Be able to set whole decoration_data instead of calling
+		// each individually?
+		if (opacity) {
+			wlr_scene_buffer_set_opacity(buffer, c->opacity);
 		}
 
-		xdg_surface = wlr_xdg_surface_try_from_wlr_surface(scene_surface->surface);
+		if (!wlr_subsurface_try_from_wlr_surface(xdg_surface->surface)) {
+			if (corner_radius > 0) {
+				wlr_scene_buffer_set_corner_radius(buffer, c->corner_radius);
+			}
 
-		if (c &&
-				xdg_surface &&
-				xdg_surface->role == WLR_XDG_SURFACE_ROLE_TOPLEVEL) {
-			if (!wlr_subsurface_try_from_wlr_surface(xdg_surface->surface)) {
+			if (shadow) {
 				wlr_scene_buffer_set_shadow_data(buffer, c->shadow_data);
 			}
-		}
-	} else if (node->type == WLR_SCENE_NODE_TREE) {
-		struct wlr_scene_tree *tree = wl_container_of(node, tree, node);
-		struct wlr_scene_node *_node;
-		wl_list_for_each(_node, &tree->children, link) {
-			output_configure_scene(_node, c);
+
+			if (blur) {
+				wlr_scene_buffer_set_backdrop_blur(buffer, 1);
+				wlr_scene_buffer_set_backdrop_blur_optimized(buffer, blur_optimized);
+				wlr_scene_buffer_set_backdrop_blur_ignore_transparent(buffer, blur_ignore_transparent);
+			}
 		}
 	}
 }
 
 void 
-iter_xdg_scene_buffers(struct wlr_scene_buffer *buffer, int sx, int sy, void *user_data) 
+iter_xdg_scene_buffers_shadow(struct wlr_scene_buffer *buffer, int sx, int sy, void *user_data) 
 {
 	Client *c = user_data;
 	struct wlr_scene_surface * scene_surface = wlr_scene_surface_try_from_buffer(buffer);
@@ -2873,17 +2895,8 @@ iter_xdg_scene_buffers(struct wlr_scene_buffer *buffer, int sx, int sy, void *us
 	if (c &&
 			xdg_surface &&
 			xdg_surface->role == WLR_XDG_SURFACE_ROLE_TOPLEVEL) {
-		// TODO: Be able to set whole decoration_data instead of calling
-		// each individually?
-		wlr_scene_buffer_set_opacity(buffer, c->opacity);
-
 		if (!wlr_subsurface_try_from_wlr_surface(xdg_surface->surface)) {
-			wlr_scene_buffer_set_corner_radius(buffer, c->corner_radius);
-			// wlr_scene_buffer_set_shadow_data(buffer, c->shadow_data);
-
-			wlr_scene_buffer_set_backdrop_blur(buffer, !optimized_blur);
-			wlr_scene_buffer_set_backdrop_blur_optimized(buffer, optimized_blur);
-			wlr_scene_buffer_set_backdrop_blur_ignore_transparent(buffer, true);
+			wlr_scene_buffer_set_shadow_data(buffer, c->shadow_data);
 		}
 	}
 }
-- 
2.43.2

